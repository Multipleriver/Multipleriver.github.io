[{"content":"Yank-Note 特色功能使用说明 English | 中文\n[toc]{type: \u0026ldquo;ol\u0026rdquo;, level: [2]}\n应用数据 \u0026lt;home\u0026gt; 为当前操作系统的用户主目录，例如：\nWindows: C:\\Users\\\u0026lt;username\u0026gt; Linux: /home/\u0026lt;username\u0026gt; macOS: /Users/\u0026lt;username\u0026gt; 应用相关的数据目录存放在 \u0026lt;home\u0026gt;/yank-note 下面，点击托盘菜单“打开主目录”即可查看\n目录说明：\n配置文件 \u0026lt;home\u0026gt;/yank-note/config.json\n导出 docx 参考文档 \u0026lt;home\u0026gt;/yank-note/pandoc-reference.docx\n文档历史版本 \u0026lt;home\u0026gt;/yank-note/histories\n[!TIP] 如果您不小心丢失了您的文档数据，您可以到此文件夹尝试找回。\n[!CAUTION] 出于性能的考虑，超过 102400 个字符的文档将不会储存历史记录。因此请谨慎在文档中嵌入 Base64 图片。\n插件 \u0026lt;home\u0026gt;/yank-note/plugins\n主题 \u0026lt;home\u0026gt;/yank-note/themes\n扩展 \u0026lt;home\u0026gt;/yank-note/extensions\n其他用户数据 \u0026lt;home\u0026gt;/yank-note/data\nTOC 生成 需要生成目录的地方写入 [toc]{type: \u0026quot;ul\u0026quot;, level: [1,2,3]} 可以控制目录样式 ul 或 ol 和级别\n待办切换 在预览界面打勾试试\n2021-06-06 10:27 TEST1 2021-06-06 10:27 TEST2 2021-06-06 10:27 TEST3 加密文档 以 .c.md 结尾的文档视为加密文档，可以用来保存机密的信息。 加密和解密过程均在前端完成。 请务必保管好文档密码，密码一旦丢失就只能自己暴力破解了。 Markdown 增强 在编辑器中键入 / 可以获得提示\n高亮：==marked== 上标：29^th^ 下标：H~2~0 脚注：脚注1语法2 Emoji: :) :joy: 缩写： *[HTML]: Hyper Text Markup Language *[W3C]: World Wide Web Consortium The HTML specification is maintained by the W3C. Github Alerts 此功能使用 markdown-it-github-alerts 实现，支持 Github 风格的警告提示。\n[!NOTE] 注意 突出强调用户在浏览时应该注意的信息。\n[!TIP] 提示 提供可选的信息以帮助用户更加成功。\n[!IMPORTANT] 重要 对于用户成功至关重要的关键信息。\n[!WARNING] 警告 由于潜在风险，需要立即引起用户的注意的关键内容。\n[!CAUTION] 小心 行动的负面潜在后果。\n元素属性书写 此功能使用 markdown-it-attributes 实现。\n红色文字，白色背景，居中和边框{.bgw .text-center .with-border style=\u0026ldquo;color:red\u0026rdquo;} 显示为块元素{.block} 转义语法{style=\u0026ldquo;color:red\u0026rdquo;} 一些内置样式类：\n类名 说明 avoid-page-break 打印/导出PDF时避免页面在此元素中断 new-page 打印/导出PDF时在此元素前分页 skip-print 打印/导出PDF时跳过此元素 skip-export 导出/复制HTML时跳过此元素 inline 当前元素显示为行内元素 block 当前元素显示为块元素 reduce-brightness 使用暗色主题时候降低此元素亮度 bgw 设置当前元素背景为白色 copy-inner-text 标记 “Ctrl/Cmd + 单击左键” 拷贝元素文字 wrap-code 应用于代码块，让其自动换行 text-left 当前元素文字左对齐 text-center 当前元素文字居中对齐 text-right 当前元素文字右对齐 with-border 给当前元素加上边框 图片增强 一个段落下如果只有一个图片元素，默认会渲染成块元素并居中。如果要强制显示为行内元素，可以在图片链接参数后面追加 .inline 如上图所示。 如果要给图片添加白色背景优化展示效果（针对某些透明图片）,可以在图片链接参数后面追加 .bgw 如： 可以使用markdown-it-imsize的方式来设置图片尺寸 例如这是一个宽度为 16px 的图片: ![](logo-small.png =16x) 思维导图 只需要在列表根节点加上 {.mindmap} 即可。\n中心节点{.mindmap} [1] 状态可见原则 [2] 环境贴切原则 [3] 用户可控原则 [4] 一致性原则 [5] 防错原则 [6] 易取原则 [7] 灵活高效原则 [8] 优美且简约原则 [9] 容错原则 [10] 人性化帮助原则 脑图使用 kityminder-core 实现。\nMermaid 图形 graph LR A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2]\rsequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good!\rgantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d\rstateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*]\rpie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15\rjourney title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me\rPlantUML 图形 您可以在 设置 中配置使用本地端点或 PlantUML 在线端点来生成图形。\n[!IMPORTANT] 如果使用本地端点，则系统需要有 Java 环境，并安装有 Graphviz 如果提示 Cannot find Graphviz，请参考 Test your GraphViz installation\n示例如下\n@startuml a -\u0026gt; b @enduml\n表格增强 此功能使用 markdown-it-multimd-table 实现 支持在表格中使用多行文本和列表。支持表格说明渲染\n您可以双击/右键单元格快捷编辑单元格内容，相关快捷键：\nDBLClick: 编辑单元格 Escape: 退出编辑 Enter: 确认编辑并编辑下一行 Shift + Enter: 确认编辑并编辑上一行 Cmd/Ctrl + Shift + Enter: 确认编辑并插入下一行 Tab: 确认编辑并编辑下一列 Shift + Tab: 确认编辑并编辑上一列 First header Second header List: More \\ over | data \\ several | Test | Test [测试表格] First header Second header AAAAAAAAAAAA BBBBBBBBBBBBBB AAAAAAAAAAAA BBBBBBBBBBBBBB AAAAAAAAAAAA BBBBBBBBBBBBBB AAAAAAAAAAAA BBBBBBBBBBBBBB AAAAAAAAAAAA BBBBBBBBBBBBBB Test Test [小尺寸表格] {.small} h1 h2 h3 x1 x2 x3 {rowspan=2 style=\u0026ldquo;color:red\u0026rdquo;} x4 {colspan=2} [合并单元格] Katex 公式 此功能由 KaTeX 提供。\n$$ \\begin{array}{c} \\nabla \\times \\vec{\\mathbf{B}} -, \\frac1c, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} \u0026amp; = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\nabla \\cdot \\vec{\\mathbf{E}} \u0026amp; = 4 \\pi \\rho \\ \\nabla \\times \\vec{\\mathbf{E}}, +, \\frac1c, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} \u0026amp; = \\vec{\\mathbf{0}} \\ \\nabla \\cdot \\vec{\\mathbf{B}} \u0026amp; = 0 \\end{array} $$\nequation description $\\nabla \\cdot \\vec{\\mathbf{B}} = 0$ divergence of $\\vec{\\mathbf{B}}$ is zero $\\nabla \\times \\vec{\\mathbf{E}}, +, \\frac1c, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} = \\vec{\\mathbf{0}}$ curl of $\\vec{\\mathbf{E}}$ is proportional to the rate of change of $\\vec{\\mathbf{B}}$ $\\nabla \\times \\vec{\\mathbf{B}} -, \\frac1c, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\nabla \\cdot \\vec{\\mathbf{E}} = 4 \\pi \\rho$ what? 运行代码 支持运行 JavaScript PHP nodejs Python bash bat 代码。 此功能执行外部命令实现，所以需要安装相应环境。\n代码块第一行需要包含以 --run-- 字符串，示例如下\n1 2 3 4 // --run-- await new Promise(r =\u0026gt; setTimeout(r, 500)) ctx.ui.useToast().show(\u0026#34;info\u0026#34;, \u0026#34;HELLOWORLD!\u0026#34;) console.log(\u0026#39;HELLOWORLD\u0026#39;) 1 2 // --run-- --output-html-- console.log(`output \u0026lt;i\u0026gt;HTML\u0026lt;/i\u0026gt;`) 1 2 // --run-- console.log(\u0026#39;HELLOWORLD\u0026#39;) 1 2 // --run-- echo \u0026#39;HELLOWORLD!\u0026#39;; 1 2 # --run-- print(\u0026#39;HELLOWORLD\u0026#39;) 1 2 # --run-- date 1 2 REM --run-- @echo HELLOWORLD 1 2 3 4 5 6 7 8 // --run-- gcc $tmpFile.c -o $tmpFile.out \u0026amp;\u0026amp; $tmpFile.out #include \u0026lt;stdio.h\u0026gt; int main () { printf(\u0026#34;Hello, World!\u0026#34;); return 0; } 1 2 3 4 5 6 7 // --run-- java $tmpFile.java class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } 集成终端 使用 Alt/Option + T 或者点击状态栏 切换终端 菜单唤起集成终端 支持在编辑器中选中一段代码后按下 Shift + Alt/Option + R 直接在终端中运行命令。免去复制粘贴。 切换内置终端工作目录到当前目录 右键目录 小工具 支持在文档中嵌入 HTML 小工具。 HTML 代码块第一行需要包含以 --applet-- 字符串，其余字符串作为小工具标题，示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!-- --applet-- Hash --\u0026gt; \u0026lt;script\u0026gt; function run (type) { const input = document.getElementById(\u0026#39;input\u0026#39;) const output = document.getElementById(\u0026#39;output\u0026#39;) output.value = \u0026#39;\u0026#39; switch (type) { case \u0026#39;md5\u0026#39;: output.value = ctx.lib.cryptojs.MD5(input.value).toString().toLowerCase() break case \u0026#39;sha1\u0026#39;: output.value = ctx.lib.cryptojs.SHA1(input.value).toString().toLowerCase() break case \u0026#39;sha256\u0026#39;: output.value = ctx.lib.cryptojs.SHA256(input.value).toString().toLowerCase() break } output.focus() output.select() } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 输入 \u0026lt;textarea id=\u0026#34;input\u0026#34; style=\u0026#34;display: block; width: 100%\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button onclick=\u0026#34;run(\u0026#39;md5\u0026#39;)\u0026#34;\u0026gt;MD5\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;run(\u0026#39;sha1\u0026#39;)\u0026#34;\u0026gt;SHA1\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;run(\u0026#39;sha256\u0026#39;)\u0026#34;\u0026gt;SHA256\u0026lt;/button\u0026gt; \u0026lt;textarea id=\u0026#34;output\u0026#34; style=\u0026#34;display: block; width: 100%\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button onclick=\u0026#34;document.getElementById(\u0026#39;input\u0026#39;).value = \u0026#39;\u0026#39;; document.getElementById(\u0026#39;output\u0026#39;).value = \u0026#39;\u0026#39;\u0026#34;\u0026gt;清空\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;var x = document.getElementById(\u0026#39;output\u0026#39;); x.value = x.value.toUpperCase()\u0026#34;\u0026gt;结果大写\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 如果没有标题，将没有外部边框装饰\n1 2 \u0026lt;!-- --applet-- --\u0026gt; \u0026lt;button onclick=\u0026#34;ctx.ui.useToast().show(`info`, `HELLOWORLD!`)\u0026#34;\u0026gt;HELLO\u0026lt;/button\u0026gt; ECharts 图形 Js 代码块第一行包含以 --echarts-- 字符串会被解析成 ECharts 图形，示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // --echarts-- const option = { // backgroundColor: \u0026#39;#2c343c\u0026#39;, title: { text: \u0026#39;Customized Pie\u0026#39;, left: \u0026#39;center\u0026#39;, top: 20, textStyle: { color: \u0026#39;#888\u0026#39; } }, tooltip : { trigger: \u0026#39;item\u0026#39;, formatter: \u0026#34;{a} \u0026lt;br/\u0026gt;{b} : {c} ({d}%)\u0026#34; }, visualMap: { show: false, min: 80, max: 600, inRange: { colorLightness: [0, 1] } }, series : [ { name:\u0026#39;访问来源\u0026#39;, type:\u0026#39;pie\u0026#39;, radius : \u0026#39;55%\u0026#39;, center: [\u0026#39;50%\u0026#39;, \u0026#39;50%\u0026#39;], data:[ {value:335, name:\u0026#39;直接访问\u0026#39;}, {value:310, name:\u0026#39;邮件营销\u0026#39;}, {value:274, name:\u0026#39;联盟广告\u0026#39;}, {value:235, name:\u0026#39;视频广告\u0026#39;}, {value:400, name:\u0026#39;搜索引擎\u0026#39;} ].sort(function (a, b) { return a.value - b.value; }), roseType: \u0026#39;radius\u0026#39;, label: { normal: { textStyle: { color: \u0026#39;#888\u0026#39; } } }, labelLine: { normal: { lineStyle: { color: \u0026#39;#888\u0026#39; }, smooth: 0.2, length: 10, length2: 20 } }, itemStyle: { normal: { color: \u0026#39;#c23531\u0026#39;, shadowBlur: 200, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } }, animationType: \u0026#39;scale\u0026#39;, animationEasing: \u0026#39;elasticOut\u0026#39;, animationDelay: function (idx) { return Math.random() * 200; } } ] } chart.setOption(option, true) Draw.io 图形 链接属性 link-type 值需要是 drawio 字符串。使用链接的形式也不会影响其他 Markdown 解析器解析。\ndrawio{link-type=\u0026ldquo;drawio\u0026rdquo;}\nLuckysheet 表格 链接属性 link-type 值需要是 luckysheet 字符串。使用链接的形式也不会影响其他 Markdown 解析器解析。\n[!WARNING] 现阶段 Luckysheet Bug 较多，使用需谨慎。\nluckysheet{link-type=\u0026ldquo;luckysheet\u0026rdquo;}\n容器块 支持类似 VuePress 容器块 功能，使用 markdown-it-container 实现\n使用\n1 2 3 ::: \u0026lt;type\u0026gt; [title] [content] ::: type 是必需的， title 和 content 是可选的。\n支持的 type 有：tip, warning, danger, details, group, group-item, row, col, section, div\n示例\n::: tip 这是一个提示 :::\n::: warning 这是一个警告 :::\n::: danger 这是一个危险警告 :::\n::: danger STOP 危险区域，禁止通行 :::\n::: details 这是一个 details 标签 :::\n::: details 点击展开更多 这是一个 details 标签 :::\n:::: group 这是标签组 ::: group-item Tab 1 test 1 :::\n::: group-item *Tab 2 test 2 标题前带 * 表示默认激活此选项卡 :::\n::: group-item Tab 3 test 3 ::: ::::\n::::: row 分列示例 :::: col TODO ::: warning Item 1 ::: ::: warning Item 2 ::: ::: warning Item 3 ::: :::: :::: col DONE ::: tip Item 4 ::: ::: tip Item 5 ::: :::: :::::\n:::: row ::: col Column 1 test 1 ::: ::: col Column 2 test 2 ::: ::: col Column 3 test 3 ::: ::::\nAI Copilot 人工智能写作助手 Yank Note 接入了 OpenAI、Google AI 等人工智能平台，可以使用人工智能进行智能补全、文本重写等功能\n[!NOTE] 相关 API token 需要你自行获取。且需要 安装并启用 AI Copilot 扩展\nFront Matter 页面支持类似 Jekyll Front Matter 配置信息\n内置变量\n变量名 类型 描述 headingNumber boolean 是否开启页面标题序号编号 wrapCode boolean 是否开启代码换行 enableMacro boolean 是否开启宏替换 define Record\u0026lt;string, string\u0026gt; 宏定义，定义文本替换 defaultPreviewer string 文档默认的预览器，某些扩展可能提供特殊的预览界面。如 Reveal.js 扩展 mdOptions Record\u0026lt;string, boolean\u0026gt; Markdown-it 解析参数 mdOptions.html boolean 开启 HTML 解析 mdOptions.breaks boolean 转换 \\n 成 \u0026lt;br\u0026gt; mdOptions.linkify boolean 自动转换链接 mdOptions.typographer boolean 开启语言替换和引号美化 katex Record\u0026lt;string, any\u0026gt; Katex 配置 宏替换 [!NOTE] 此功能 高级版可用\nYank Note 允许你在页面中嵌入宏，用以动态地替换文档。\n[!IMPORTANT] 使用前需要先在 Front Matter 开启宏替换，定义 enableMacro: true。\n[!WARNING] 使用宏替换可能会导致源码和预览行号对应不准确，Yank Note 已经尽可能处理，但某些情况可能仍然会出现同步滚动异常。\n文本替换 Front Matter 中的 define 字段可以定义一些文本替换映射。支持在另一个文件定义，支持宏表达式。具体可参考本文件顶部 Front Matter 部分。\n[!TIP] 你还可以在设置中配置 全局宏替换 ，这样所有文档都可以使用。不过，你仍然需要在 Front Matter 中定义 enableMacro: true。\n应用名: \u0026ndash;APP_NAME\u0026ndash; 应用版本: \u0026ndash;APP_VERSION\u0026ndash; 另一个文件的定义: \u0026ndash;TEST_DEFINE\u0026ndash; 宏表达式 语法：\n1 [= \u0026lt;expression\u0026gt; =] 其中 expression 是需要执行的 js 表达式，支持 await/Promise 异步表达式。\n如果表达式中需要包含 [= 或 =] 请输入 [\\= 或 =\\] 转义替换\n一些示例 是否开启页面标题序号编号: [= headingNumber =] 使用变量: [= customVar =] 定义变量: [= $export(\u0026rsquo;testVar\u0026rsquo;, \u0026lsquo;Test\u0026rsquo;) =][= testVar =] 定义函数: [= $export(\u0026lsquo;format\u0026rsquo;, (a, b) =\u0026gt; ${a}, ${b}!) =][= format(\u0026lsquo;HELLO\u0026rsquo;, \u0026lsquo;WORLD\u0026rsquo;) =] 进一步处理: XXXXXXXXXXXXXX [= $afterMacro(src =\u0026gt; src.replace(/X{4,}/g, \u0026lsquo;YYYYY\u0026rsquo;)) =] 应用版本：[= $ctx.version =] 当前文档名: [= $doc.basename =] 当前时间: [= $ctx.lib.dayjs().format(\u0026lsquo;YYYY-MM-DD HH:mm\u0026rsquo;) =] 计数器: [= $seq图- =] | [= $seq图- =] | [= $seq图- =] | [= $seq表- =] | [= $seq表- =] 限定符转义: [= \u0026lsquo;[= =]\u0026rsquo; =] 四则运算: [= (1 + 2) / 2 =] 引用文件（支持最多嵌套 3 层，可使用目标文档中定义的 Front Matter 变量) [= $include(\u0026rsquo;./_FRAGMENT.md\u0026rsquo;, true) =]\n被引用文档中定义的变量：[= customVarFromOtherDoc =] 你的 IP 地址：[= fetch(\u0026lsquo;https://ifconfig.me/ip\u0026rsquo;).then(r =\u0026gt; r.text()) =] 天气预报 1 [= await ctx.utils.sleep(1000), fetch(\u0026#39;https://wttr.in?0AT\u0026#39;).then(r =\u0026gt; r.text()) =] 九九乘法表 [= (function nine (num) { let res = \u0026rsquo;\u0026rsquo; for (let i = 1; i \u0026lt;= num; i++) { let str = \u0026lsquo;\u0026rsquo;; for (let k = 1; k \u0026lt;= num; k++) { if (i \u0026gt;= k) { str += k + \u0026lsquo;x\u0026rsquo; + i + \u0026lsquo;=\u0026rsquo; + i*k + \u0026rsquo; \u0026lsquo;; } } res = res + str + \u0026lsquo;\\n\u0026rsquo; } return res })(9) =] 可用变量 宏表达式可以使用在 Front Matter 定义的变量，也可以使用下面的内置变量\n变量名 类型 描述 $ctx object 编辑器 ctx，可参考插件开发指南 和Api 文档 $include (path: string, trim = false) =\u0026gt; Result 引入其他文档片段方法 $export (key: string, val: any) =\u0026gt; Result 定义一个本文档可以使用的变量 $noop () =\u0026gt; Result 无操作函数，可用于文本占位使用 $afterMacro (fn: (src: string) =\u0026gt; string) =\u0026gt; Result 定义一个宏替换后的回调函数，可用于对替换后的文本进行进一步处理。 $seq (label: string) =\u0026gt; Result 文档内部计数器 $doc object 当前文档信息 $doc.basename string 当前文档文件名（无后缀） $doc.name string 当前文档文件名 $doc.path string 当前文档路径 $doc.repo string 当前文档仓库 $doc.content string 当前文档内容 $doc.status 'loaded', 'save-failed', 'saved' 当前文档状态 命令行参数 在向别人交接文档的时候，可以使用脚本，自定义命令行参数启动程序，方便对方查看文档。\n名称 作用 默认值 说明 示例 \u0026ndash;port 服务器监听端口 3044 端口 \u0026ndash;port=8080 \u0026ndash;disable-tray 禁用常驻托盘 false true/false \u0026ndash;disable-tray \u0026ndash;readonly 编辑器只读 false true/false \u0026ndash;readonly \u0026ndash;show-status-bar 显示状态栏 true true/false \u0026ndash;show-status-bar=false \u0026ndash;data-dir 数据目录 无 目录路径字符串 \u0026ndash;data-dir=\u0026rsquo;./.data\u0026rsquo; \u0026ndash;init-repo 初始仓库名 无 字符串 \u0026ndash;init-repo=\u0026lsquo;test\u0026rsquo; \u0026ndash;init-file 加载文件路径 无 文件路径，相对于仓库路径 \u0026ndash;init-file=\u0026rsquo;/1.md\u0026rsquo; 自定义样式 右键点击托盘图标，点击“打开主目录”，进入 \u0026lt;主目录\u0026gt;/themes 目录。 复制 github.css 为一个新 CSS 文件，修改 CSS 内容 打开设置 =\u0026gt; 外观 =\u0026gt; 自定义 CSS 切换 CSS 配置 插件开发 请参考插件开发指南\n这是一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这也是一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-01-20T17:17:26+08:00","permalink":"https://Multipleriver.github.io/p/yank-note-%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"Yank-Note 特色功能使用说明"},{"content":"实验1：简单 IO 实验 任务 控制 8 个 LED 依次点亮，模拟流水灯试验。 利用一个独立式按键控制一个 LED 灯的亮灭，每按 一次键，灯状态改变一次状态，用中断方式实现。 在一位数码管上逐次静态显示数字 0~9 和字母 A~F。 流程图 LED 流水灯 独立按键控制 LED 灯亮灭 数码管显示 程序 LED 流水灯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;msp430f149.h\u0026gt; #include \u0026#34;config.h\u0026#34; #include \u0026#34;uint.h\u0026#34; void main (void) { WDTCTL=WDTPW+WDTHOLD; //关闭看门狗 BoardConfig(); //端口初始化 Clock_Init(); //时钟初始化 while(1) { uint8 led_code=BIT0; // 0000 0001 uint8 i; for(i=0;i\u0026lt;8;i++) { P2DIR=0xFF; //P2流水灯端输出，低电平点亮 P2OUT=~led_code; //P2不断翻转，控制亮灭 delay_ms(1000); //1s延时 led_code\u0026lt;\u0026lt;=1; //持续左移一位 } } } 独立按键控制 LED 灯亮灭 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;msp430f149.h\u0026gt; #include \u0026#34;config.h\u0026#34; void main(void) { WDTCTL=WDTPW+WDTHOLD; //关闭看门狗 BoardConfig(); //端口初始化 Clock_Init(); //时钟初始化 P2DIR|=BIT7; //P2.7输出，控制第8个LED灯 P1IES|=BIT0; //下降沿触发中断 P1IFG\u0026amp;=~BIT0; //清除P1.0口中断标志 P1IE|=BIT0; //P1.0口中断使能，第一个独立按键 _BIS_SR(LPM3_bits+GIE); //进入低功耗模式，全局中断 } #pragma vector=PORT1_VECTOR __interrupt void PORT1(void) { if(P1IFG\u0026amp;BIT0) //判断是否为P1.0产生的中断，如果是就执行以下程序 { P2OUT^=BIT7; //翻转LED灯状态 while(!(P1IN\u0026amp;BIT0)); //等待按键释放 delay_ms(100); //延时，按键去抖 P1IFG=0; //清除中断标志位 } } 数码管显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;msp430f169.h\u0026gt; #include \u0026#34;config.h\u0026#34; #include \u0026#34;uint.h\u0026#34; #include \u0026#34;digit_disp.h\u0026#34; void main(void) { WDTCTL=WDTPW+WDTHOLD; //关闭看门狗 BoardConfig(); //端口初始化 Clock_Init(); //时钟初始化 while(1) { unsigned int i; for(i=0;i\u0026lt;16;i++) { display1Digit(i, BIT7); //轮次显示 delay_ms(1000); //延时1s } } } 实验结果 实验心得 本次实验主要目的是掌握 IO 端口的使用方法。在实验中我通过控制端口在需要的时候输出高、低电平来完成 LED 灯的亮灭变化，通过给数码管送译码完的数来完成数码管显示。\n在第一个实验中，板子出现了灯没有按预期闪烁的问题，经调试后发现，应在 while 循环中每次左移后调用延时函数，使得 LED 灯的当前状态持续一段时间后再改变状态，才可以达到闪烁的效果。合理调用延时函数也可以消除按键抖动。\n在第二个实验中，我是用了触发中断函数来配合按键按下，这样避免了系统轮询带来的额外功耗。\n在第三个实验中，考虑到数码管显示是十分常用的模块，我将其封装为 display1Digit 和 display2Digits 函数，以便以后调用。在批量调试和调用相同模块的时候，模块化封装是很有必要的。\n实验2：三人投票表决器 任务 三人投票表决器，按下按键进行表决，对应的 LED 灯点亮，数码管显示按下按键的个数。\n流程图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026#34;msp430f149.h\u0026#34; #include \u0026#34;config.h\u0026#34; #include \u0026#34;uint.h\u0026#34; #include \u0026#34;digit_disp.h\u0026#34; unsigned char i0=0; //记录第一个按键是否按过 unsigned char i1=0; //记录第二个按键是否按过 unsigned char i2=0; //记录第三个按键是否按过 void main(void) { WDTCTL = WDTPW + WDTHOLD; BoardConfig(); Clock_Init(); P4DIR|=0xFF; P5DIR|=BIT5; P6DIR|=BIT6; P2DIR|=0xFF; P1DIR\u0026amp;=~(BIT0+BIT1+BIT2); //端口方向 P1IES|=BIT0+BIT1+BIT2; //边沿触发 P1IFG\u0026amp;=~(BIT0+BIT1+BIT2); //清除中断标志 P1IE|=BIT0+BIT1+BIT2; //中断使能 _BIS_SR(LPM3_bits+GIE); //回归低功耗模式，全局中断 while(1); } #pragma vector=PORT1_VECTOR __interrupt void Port_1 (void) { if(1) display1Digit((i0+i1+i2),BIT7); delay_ms(10); if(P1IFG\u0026amp;BIT0) //检查第一个按键 { if(i0==0) { P2OUT^=BIT0; //翻转LED delay_ms(10); while(!(P1IN\u0026amp;BIT0));//检查按键释放 P1IFG\u0026amp;=~BIT0; //清除中断标志 i0=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } if(i0==1) { delay_ms(10); while(!(P1IN\u0026amp;BIT0));//检查按键释放 P1IFG\u0026amp;=~BIT0; //清除中断标志 i0=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } } if(P1IFG\u0026amp;BIT1) //检查第二个按键 { if(i1==0) { P2OUT^=BIT1; delay_ms(10); while(!(P1IN\u0026amp;BIT1)); P1IFG\u0026amp;=~BIT1; i1=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } if(i1==1) { delay_ms(10); while(!(P1IN\u0026amp;BIT1)); P1IFG\u0026amp;=~BIT1; i1=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } } if(P1IFG\u0026amp;BIT2) //检查第三个按键 { if(i2==0) { P2OUT^=BIT2; delay_ms(10); while(!(P1IN\u0026amp;BIT2)); P1IFG\u0026amp;=~BIT2; i2=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } if(i2==1) { delay_ms(10); while(!(P1IN\u0026amp;BIT2)); P1IFG\u0026amp;=~BIT2; i2=1; display1Digit((i0+i1+i2),BIT7); delay_ms(10); } } } 实验结果 实验心得 在这次的实验中，我在表决器中引入了 i0、i1、i2 三个 flag 来记录按键状态，并在中断子程序中根据他们的值显示不同代码。画流程图（含中断）很有必要。有了流程图才能更方便精准地确定程序走向、初始化变量、构造子程序框架。\n美中不足的是，这次程序在开发板上跑的并不是很理想，在多次频繁按下按键后程序显示不出对应的数值。\n实验3：矩阵键盘显示 任务 初始状态下所有数码管都熄灭，分别按下矩阵键盘的按键 K1~K16，最右的两位数码管显示对应数值 01~16，其余数码管熄灭。\n流程图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;msp430f149.h\u0026gt; #include \u0026#34;config.h\u0026#34; #include \u0026#34;uint.h\u0026#34; #include \u0026#34;digit_disp.h\u0026#34; #include \u0026#34;keyboard.h\u0026#34; void timerInit(void); void main(void) { WDTCTL=WDTPW+WDTHOLD; //关闭看门狗 BoardConfig(); //端口初始化 Clock_Init(); //时钟初始化 timerInit(); _EINT(); //打开全局中断 while(1) { keyboardScan(); //低速：键盘扫描获取键值，送入缓冲区 } } void timerInit(void) { TACTL = TASSEL_1 + ID_3 + MC_1; //定时器A的时钟源选择ACLK，增计数模式 CCTL0 = CCIE; //使能CCR0中断 CCR0 = 10; //设定刷新周期2mS } #pragma vector = TIMERA0_VECTOR __interrupt void Timer_A (void) { display2Digits(Dispbuf,BIT7,BIT6); //高速：定时器控制刷新数码管，显示缓冲区数据 } 实验结果 实验心得 我认为这次实验是我完成的最优雅的一次实验，而低速读取键盘和高速刷新数码管是其中最优雅的部分。同时，在做到这个实验时，我开始封装部分经常使用的模块，这使得程序进一步形式精简，结构进一步优化。\n实验4：人行交通灯控制器 任务 利用定时器 A 实现人行交通灯的控制。\n初始状态红灯点亮； 按下按键后，保持红灯点亮的状态下，数码管从 10s 开始倒计时，当倒计时到 0 时，红灯熄灭， 绿灯点亮，行人可以通行； 在绿灯点亮的状态下，进行 15s 倒计时，倒计时到 3s 时，绿灯以 1s 为周期进行闪烁（每半秒改变一次状态），提醒行人绿灯即将结束，倒计时到 0 时，红灯点亮，数码管倒计时结束。 流程图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;msp430f149.h\u0026gt; #include \u0026#34;config.h\u0026#34; #include \u0026#34;uint.h\u0026#34; #include \u0026#34;digit_disp.h\u0026#34; int t=0;//t是程序总的执行时间 void main(void) { WDTCTL = WDTPW+WDTHOLD; //关闭看门狗 BoardConfig(); P4DIR=0xFF; //端口初始化 P5DIR|=BIT5; P6DIR|=BIT6; P2DIR=0xFF; P2OUT\u0026amp;=~BIT0; P2OUT|=BIT3; //P2.0红灯, P2.3绿灯 TA0CCR0=32768/4; //定时0.5s,因为是增减计数 TA0CTL=TASSEL_1+MC_3+TACLR; //ACLK，增减计数模式，清除TAR TA0CCTL0=CCIE; //打开定时器中断使能 while(1) //按一次键执行一次完整的交通灯周期 { if (!(P1IN\u0026amp;BIT0)) //判断P1.0按键是否按下 { t=0; TA0CTL|=TACLR; //清除TAR while(!(P1IN\u0026amp;BIT0)); //按键是否按下 __delay_cycles(100); //延时消除抖动 _BIS_SR(GIE); //开启总中断 while(t\u0026lt;=20) { display2Digits(10-t/2,BIT7,BIT6); } P2OUT|=BIT0; // 红灯灭 P2OUT\u0026amp;=~BIT3; // 绿灯亮 while(t\u0026lt;=50) //最后几秒手动控制亮灭 { if(t==44) { P2OUT|=BIT3; } if(t==45) { P2OUT\u0026amp;=~BIT3; } if(t==46) { P2OUT|=BIT3; } if(t==47) { P2OUT\u0026amp;=~BIT3; } if(t==48) { P2OUT|=BIT3; } if(t==49) { P2OUT\u0026amp;=~BIT3; } display2Digits(25-(t/2),BIT7,BIT6); } P2OUT|=BIT3; //绿灯灭 P2OUT\u0026amp;=~BIT0; //红灯亮 } } } #pragma vector=TIMERA0_VECTOR __interrupt void TIMERA0_ISR(void) { t++; //每个定时周期自加 TA0CTL\u0026amp;=~TAIFG; //清除中断标志位 } 实验结果 实验心得 本次实验难度较高，在拿到题目的时候，我很难一下子就有思路。主程序和中断怎么搭配、程序结构是什么样的、就着哪一条线索写程序，这些都让我感到困扰。但是真正写起来了就慢慢有了头绪，初改几次就能结束。这让我意识到，脑子里多想一想还不如手上多写一写。\n实验5：简易数字电压表 任务 设计简易数字电压表，实现电压检测和显示功能。P6.0 引脚（A0 通道）采集模拟电压，利用 ADC12 模块 实现模数转换，1602 液晶屏显示电压测量结果。要求 ADC 采用内部 2.5V 基准电压，单通道多次转换模式。通过调节电位器，可以更改输入电压，测量结果最大显示值为 2.500V，精确到小数点后第三位。\n流程图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026#34;msp430f149.h\u0026#34; #include \u0026#34;config.h\u0026#34; #include \u0026#34;cry1602.h\u0026#34; #include \u0026#34;cry1602.c\u0026#34; unsigned char Number[]={\u0026#34;0123456789.\u0026#34;}; unsigned char Title[]={\u0026#34;Volt:\u0026#34;}; void Trans_val(unsigned long Hex_Val) { unsigned long Curr_Volt; //十进制电压值 unsigned int i; //电压值数组参数 unsigned char Curr_Volt_Disp[5]; //电压值显示数组 Curr_Volt=Hex_Val*2500/4095; Curr_Volt_Disp[4]=Curr_Volt/1%10; Curr_Volt_Disp[3]=Curr_Volt/10%10; Curr_Volt_Disp[2]=Curr_Volt/100%10; Curr_Volt_Disp[0]=Curr_Volt/1000%10; Curr_Volt_Disp[1]=10; for(i=0;i\u0026lt;=4;i++) Disp1Char((5+i),0,Number[Curr_Volt_Disp[i]]); } void main(void) { WDTCTL = WDTPW + WDTHOLD; Clock_Init(); //时钟初始化 P1DIR=0xFF;P1OUT=0xFF; //端口初始化 P2DIR=0xFF;P2OUT=0xFF; P3DIR=0xFF;P3OUT=0xFF; P4DIR=0xFF;P4OUT=0xFF; P5DIR=0xFF;P5OUT=0xFF; P6DIR=0xFF;P6OUT=0xFF; P6DIR|=BIT2;P6OUT|=BIT2; LcdReset(); //液晶初始化 DispNChar(0,0,5,Title); //显示\u0026#39;Volt:\u0026#39; Disp1Char(10,0,\u0026#39;v\u0026#39;); //显示电压值 P6SEL|=BIT0; //采样通道 ADC12CTL0=ADC12ON+REFON+REF2_5V+SHT0_2+MSC; //打开ADC12_A，打开内部2.5V参考电压，周期16，多路采样转换 ADC12CTL1=ADC12SSEL_0+SHP+CONSEQ_2+CSTARTADD_4; //单通道重复转换，信号来自采样定时器，单通道重复，寄存器4 ADC12MCTL4=SREF_1+INCH_0+EOS; //A4通道输入，VR+=VREF+，VR-=AVSS ADC12IE|=0x0010; //4通道中断使能 _EINT(); ADC12CTL0|=ENC+ADC12SC; //转换使能，转换启动 } #pragma vector=ADC_VECTOR __interrupt void ADCISR(void) { unsigned long result=ADC12MEM4; delay_ms(500); //延时去抖动 Trans_val(result); } 实验结果 实验心得 本次实验也有一定难度，我调试了好长时间却始终不行。在老师的帮助下，我对 ADC12MEM 寄存器输出格式有了进一步理解，并成功将其转化成十进制数值，逐位显示在液晶屏幕上；解决显示数据始终差约 32 倍的玄学问题后，我对中断和 ADC 转换模式的匹配也有了更深刻的理解。\n实验6：UART 串口通信 任务 利用 MSP430 单片机和 PC 机进行 UART 串口通信，要求 430 单片机把从 PC 机接收到的数据再发送 给 PC 机，利用串口调试工具查看结果。\n数据格式为 7 个数据位，1 个奇校验位，2 个停止位；波特率为 1200。\n流程图 程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;msp430f149.h\u0026gt; #include \u0026#34;config.h\u0026#34; void main(void) { WDTCTL=WDTPW+WDTHOLD; BoardConfig(); Clock_Init(); P3SEL|=BIT4+BIT5; //P3.4和P3.5设为UART模式,选择串口收发功能 P3DIR|=BIT4; //设P3.4输出 P3DIR\u0026amp;=~BIT5; //设3.5输入 U0CTL|=SWRST; //开始设置 U0CTL=PENA+SPB; //设置数据格式 U0BR0=0x1B; U0BR1=0x00; //设置波特率 U0TCTL|=SSEL0; //设置ACLK为时钟源(32768Hz) U0CTL\u0026amp;=~SWRST; //结束设置 ME1|=URXE0+UTXE0; IE1|=URXIE0; _EINT(); //开全局中断 } #pragma vector=UART0RX_VECTOR __interrupt void UART0_RX(void) { while(!(IFG1\u0026amp;UTXIFG0)); //如果已经发送完成 TXBUF0=RXBUF0; //将接受的送入发送端 } 实验结果 实验心得 本次实验难度不高，但是仍有细节需要注意。例如 U0CTL|=SWRST; 和 U0CTL\u0026amp;=~SWRST; 这一对指令不能忘记，在最后测试的时候需要接上额外的 232 串口线而不是用 usb 端口。这些细节都是影响实验结果的关键。\n课程设计总结 首先我十分感谢老师和同学的帮助，是他们的帮助让我巩固了书本知识，锻炼了编程能力，掌握了调试技巧，最终顺利完成所有实验。\n本课程设计的内容的每一部分，我都踏踏实实地完成，因此我也有很多心得感想。\n在 IO 接口实验中，我熟悉了 IAR、MSPFET 的使用，了解了单片机程序设计到实现的基本过程。尽管实验内容本身很简单，但是在接触复杂实验之前通过一次简单的实验来掌握框架是十分重要的。在理论学习的时候我就对中断有很多疑问甚至十分畏惧，因此我通过1.2实验重温了中断原理和触发机制，也巩固了多源中断和标志位清零的相关内容。\n在投票器实验中，我用顺序结构完成了所要求的内容，尽管这个投票器只能运行一轮……显然它不能称得上是一份“优雅”的设计，因为完备性始终是需要考虑的一环，虽然它并不在实验要求之内，但这对于我自己来说是个遗憾。\n矩阵键盘是我做的最兴奋的实验。一开始我使用静态显示和主函数内动态显示，都不能很好地完成两位数的同时显示。同时，身边的同学和我都出现了数码管余晖过于明显的问题。结合我自己对于 LCD 背光显示的一些基本了解，我认为这是数码管刷新率太低导致的。我想到接口里面学到的高速低速分开处理的策略，将这个思路迁移到实验中，把获取键盘这一低速任务放到主函数，把数码管实时刷新这个高速任务放进中断，同时设置一个计时器高频率触发中断，以达到高低速进程分开的目的。\n当老师考核的时候抽到我这个实验，我真是为这个思路而感到兴奋。这让我对计时器中断有了进一步认识：计时器中断可以产生不同形状可频率的波形，也可以利用这些波形来选择性地触发进程，从而达到高低速分开的优化效果。\n也是在矩阵键盘的实验中，我尝试封装了常用的数码管显示函数和它们需要的 array[ ] 译码数组。我认为模块化和可移植性是衡量一份代码是否“优雅”最基础的指标。假如一份代码所有的功能全都写在一个文件中，或是写在一个主函数里面，变量作用域模糊、函数内容耦合严重等问题就会接踵而至。我力求以“说人话”的方式封装了几个函数，也尝试在其他同学的主程序中调用，均能实现功能。\n交通灯的实验我一开始并没有什么思路，正如我在对应实验的心得体会中所言，在拿到题目的时候，我很难一下子就有思路。主程序和中断怎么搭配、程序结构是什么样的、就着哪一条线索写程序，这些都让我感到困扰。但是真正写起来了就慢慢有了头绪，初改几次就能结束。这让我意识到，脑子里多想一想还不如手上多写一写，如果不知道怎么写就先用简单的顺序结构，写一遍出来再慢慢调整，总会有柳暗花明的时候。\nADC电压表实验也同样令我难忘。本来简简单单程序跑出来的结果始终非常小，但是在我发现调整 Curr_Volt=Hex_Val*2500/4095; 的分子可以比例扩大输出值后，我调出了一个让大家啼笑皆非的分子 77558。老师也帮我 debug 好长时间，一开始注意点都在变量类型上，后来才发现是我自己一个累计 32 次后取均值输出一次的去抖动的“微操”和中断触发不匹配，导致结果差了约 32 倍。\n这次实验加深了我对于寄存器输出值的理解。我也认识到，主进程和触发中断的模式应该要匹配，这样才能发挥作用。\n在想不出什么好办法后，也要敢于厚着脸皮试试看，能不能通过“土办法”解决问题。这并不是一件令人羞耻的事情。\n那天晚上我准备去吃饭，在电梯口遇到了刚刚下楼，却想到问题马上又上来的老师。我们不约而同认为是变量类型的问题（尽管并不是），又一起 debug 了好一会儿。\n我十分感动，不仅仅是因为老师把我的实验 bug 放在心上，也是因为我感受到了在硬件爱好者群体中（在学校同学群体中十分少见的）才有的那种不解决完 bug 不罢休的激情。\nUART 实验到十分简单，并没有什么特别的感想。\n我在撰写这份实验报告的时候，想到那令我满意的矩阵键盘，心中不免再次激动。但是几天前，我在网上偶然接触到一些电脑外设的设计，其中行列扫描、并入串出、高低速分离、冲突处理等等，原来都是别人早就玩烂了的成熟功能，而我还在为一个矩阵键盘的“小聪明”而洋洋得意。这是何等的鼠目寸光。\n不过这也正常，有谁不会为自己一个巧妙的设计而兴奋呢？如果我下次想到一种巧妙的设计，不会感到它十分“优雅”，而是感到十分“基操”，那也许就意味着我掌握的技术体系再一次进步了。\n最后，我再次感谢老师同学的帮助。这真是一次难忘的课设！\n附件 uint.h 1 2 3 4 //------------------------------------------------------------------预定义 #define uint8 unsigned char //8位数 #define uint16 unsigned int //16位数 //----------------------------------------------------------------------- digit_disp.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //------------------------------------------------------------------预定义 #define digitSelectionOn P5OUT|=BIT5 //数码管位选开启 #define digitSelectionOff P5OUT\u0026amp;=~BIT5 //数码管位选关闭 #define segmentSelectionOn P6OUT|=BIT6 //数码管段选开启 #define segmentSelectionOff P6OUT\u0026amp;=~BIT6 //数码管段选关闭 //----------------------------------------------------------------------- //-------------------------------------------------------------全局变量区 //\u0026lt;变 量 类 型\u0026gt; \u0026lt;变 量 名\u0026gt; \u0026lt;含 义\u0026gt; \u0026lt;被使用函数\u0026gt; // uint8 [] array 数码管显示译码表 display1Digit // display2Digits //----------------------------------------------------------------------- //--------------------------------------------------------------总函数声明 void display1Digit(uint8 num, uint8 location); void display2Digits(uint16 num,uint8 location0,uint8 location1); //----------------------------------------------------------------------- /*********************************************** 函数名称：display1Digit、display2Digits 功 能：数码管动态显示（1位和2位） 参 数：num--待显示数字 location、location0、location1--显示位置 可选BIT0~BIT7 对应八只数码管最左边到最右边 返回值 ：无 ***********************************************/ uint8 array[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71}; void display1Digit(uint8 num, uint8 location) { segmentSelectionOff; //关闭段选 P4OUT=~location; //选择位选 digitSelectionOn; //打开位选 digitSelectionOff; //关闭位选 P4OUT=array[num]; //段选输出相应数码 segmentSelectionOn; //打开段选 } void display2Digits(uint16 num,uint8 location0,uint8 location1) { display1Digit(num%10,location0); //个位数 delay_us(1000); display1Digit(num/10,location1); //十位数 delay_us(1000); } keyboard.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 //------------------------------------------------------------------预定义 #define keyin_x (P1IN \u0026amp; 0x0f) //键盘函数行坐标扫描运算 //----------------------------------------------------------------------- //-------------------------------------------------------------全局变量区 //\u0026lt;变 量 类 型\u0026gt; \u0026lt;变 量 名\u0026gt; \u0026lt;含 义\u0026gt; \u0026lt;被使用函数\u0026gt; // uint8 Dispbuf 键盘缓冲区变量 keyboardScan //----------------------------------------------------------------------- //--------------------------------------------------------------总函数声明 void delay(void); uint8 keyboardScan(void); //----------------------------------------------------------------------- /*********************************************** 函数名称：delay（也可用config.h里的delay_us） 功 能：延时消抖 参 数：无 返回值 ：无 ***********************************************/ void delay(void) { uint16 tmp; for(tmp = 12000;tmp \u0026gt; 0;tmp--); } /*********************************************** 函数名称：keyboardScan 功 能：键盘扫描，存入缓冲区 参 数：无 返回值 ：Dispbuf ***********************************************/ uint8 Dispbuf=0; //缓冲区全局变量 uint8 keyboardScan(void) //二级定位，先定列坐标，再行扫描 { uint8 temp; P1DIR=0XF0; //P1.0~P1.3（PA10~PA13）输入（行坐标） P1OUT=0X0F; //P1.4~P1.7（PA14~PA17）输出清零 if(keyin_x != 0x0f) //若有键被按下 { delay(); //延时消抖 if(keyin_x != 0x0f) //再次检测按键状态 { P1OUT = 0XE0; //P1.4置零，固定按键列坐标，即只扫描第一行；此时观察P1.0~P1.3哪一位为0就能确定按键的行坐标 temp = keyin_x; //取低四位 switch(temp) //转换键值 { case 0x0e: Dispbuf = 1; break; case 0x0d: Dispbuf = 2; break; case 0x0b: Dispbuf = 3; break; case 0x07: Dispbuf = 4; break; } P1OUT = 0XD0; //P1.5置零，同理 temp = keyin_x; //取低四位 switch(temp) //转换键值 { case 0x0e: Dispbuf = 5; break; case 0x0d: Dispbuf = 6; break; case 0x0b: Dispbuf = 7; break; case 0x07: Dispbuf = 8; break; } P1OUT = 0XB0; //P1.6置零，同理 temp = keyin_x; //取低四位 switch(temp) //转换键值 { case 0x0e: Dispbuf = 9; break; case 0x0d: Dispbuf = 10; break; case 0x0b: Dispbuf = 11; break; case 0x07: Dispbuf = 12; break; } P1OUT = 0X70; //P1.5置零，同理 temp = keyin_x; //取低四位 switch(temp) //转换键值 { case 0x0e: Dispbuf = 13; break; case 0x0d: Dispbuf = 14; break; case 0x0b: Dispbuf = 15; break; case 0x07: Dispbuf = 16; break; } } } return Dispbuf; } ","date":"2024-01-19T17:17:26+08:00","permalink":"https://Multipleriver.github.io/p/%E5%8D%95%E7%89%87%E6%9C%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","title":"单片机课程设计"}]